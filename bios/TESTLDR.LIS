ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    1
CP/M V3.0 Loader

                                	.z80		; Assemble with ZSM4 or M80
                                
                                ;	Copyright (C) 1982
                                ;	Digital Research
                                ;	Box 579, Pacific Grove
                                ;	California, 93950
                                
                                ;  Revised:
                                ;    01 Nov 82  by Bruce Skidmore
                                ;
                                ; Modification History
                                ;
                                ;	15-Jun-2008	Tony Nicholson	Fix absolute base address
                                ;					equates (we can't assume
                                ;					this code runs at 0100h
                                ;					when linked with the LDRBOOT
                                ;					routine) and change break
                                ;					to halt for debugging under
                                ;					SIMH.  A conditional in LDRBOOT
                                ;					(HALT$LDR) will cause this to
                                ;					be triggered.  Also change the
                                ;					sign-on message to remove the
                                ;					clear screen line-feeds.
                                ;
                                ;	13-Aug-2018	Tony Nicholson	Included an assembly-time definition
                                ;					to alter the name of the system
                                ;					image.  TEST -> A:TEST.SYS
                                ;					Also increased the stack space.
                                ;
                                
                                	aseg	; Absolute address
                                
  0000  =                       	org	0000h		; Base of TPA
                                
  0000  =                       base	equ	$
  0000  =                       abase	equ	base
                                
  000D  =                       cr	equ	0dh
  000A  =                       lf	equ	0ah
                                
  005C  =                       fcb	equ	abase+005ch	; Default FCB address
  0080  =                       buff	equ	abase+0080h	; Default buffer address
                                
                                ;
                                ;	System Equates
                                ;
  000D  =                       resetsys equ	13		; Reset disk system
  0009  =                       printbuf equ	09		; Print string
  000F  =                       open$func equ	15		; Open function
  0014  =                       read$func equ	20		; Read sequential
  001A  =                       setdma$func equ	26		; Set dma address
                                ;
                                ;	Loader Equates
                                ;
  0080  =                       comtop	equ	abase+80h
  0081  =                       comlen	equ	abase+81h
  0082  =                       bnktop	equ	abase+82h
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    2
CP/M V3.0 Loader

  0083  =                       bnklen	equ	abase+83h
  0084  =                       osentry equ	abase+84h
                                
                                	cseg	; Code Segment
                                
  0000' 31 0181'                rbase::	ld	sp,stackbot	; Stack can overwrite sign-on
                                
  0003' CD 0A00'                	call	bootf		; First call is to Cold Boot
                                
  0006' 0E 0D                   	ld	c,resetsys	; Initialize the System
  0008' CD 018D'                	call	bdos
                                
  000B' 0E 09                   	ld	c,printbuf	; Print the sign on message
  000D' 11 0132'                	ld	de,signon
  0010' CD 018D'                	call	bdos
                                
  0013' 0E 0F                   	ld	c,open$func	; Open the CPM3.SYS file
  0015' 11 00AB'                	ld	de,cpmfcb
  0018' CD 018D'                	call	bdos
  001B' FE FF                   	cp	0ffh
  001D' 11 00CF'                	ld	de,openerr
  0020' CA 00A2'                	jp	z,error
                                
  0023' 11 0080                 	ld	de,buff
  0026' CD 008F'                	call	setdma$proc
                                
  0029' CD 0095'                	call	read$proc	; Read the load record
                                
  002C' 21 0080                 	ld	hl,buff		; Copy res, bnk, xfr fields
  002F' 11 0181'                	ld	de,mem$top
  0032' 0E 06                   	ld	c,6
  0034'                         cloop::
  0034' 7E                      	ld	a,(hl)
  0035' 12                      	ld	(de),a
  0036' 13                      	inc	de
  0037' 23                      	inc	hl
  0038' 0D                      	dec	c
  0039' C2 0034'                	jp	nz,cloop
                                	
  003C' CD 0095'                	call	read$proc	; Read display info
                                
  003F' 0E 09                   	ld	c,printbuf	; Print the info
  0041' 11 0080                 	ld	de,buff
  0044' CD 018D'                	call	bdos
                                	
                                ;
                                ;	Main System Load
                                ;
                                
                                ;
                                ;	Load Common Portion of System
                                ;
  0047' 3A 0182'                	ld	a,(res$len)
  004A' 67                      	ld	h,a
  004B' 3A 0181'                	ld	a,(mem$top)
  004E' CD 0073'                	call	load
                                ;
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    3
CP/M V3.0 Loader

                                ;	Load Banked Portion of System
                                ;
  0051' 3A 0184'                	ld	a,(bank$len)
  0054' B7                      	or	a
  0055' CA 005F'                	jp	z,$execute
  0058' 67                      	ld	h,a
  0059' 3A 0183'                	ld	a,(bank$top)
  005C' CD 0073'                	call	load
                                ;
                                ;	Execute System
                                ;
  005F'                         $execute::
  005F' 21 005D                 	ld	hl,fcb+1
  0062' 7E                      	ld	a,(hl)
  0063' FE 24                   	cp	'$'
  0065' C2 006F'                	jp	nz,execute$sys
  0068' 23                      	inc	hl
  0069' 7E                      	ld	a,(hl)
  006A' FE 42                   	cp	'B'
  006C' CC 00A9'                	call	z,break
  006F'                         execute$sys:
  006F' 31 0185'                	ld	sp,osentry$adr
  0072' C9                      	ret
                                
                                ;
                                ;	Load Routine
                                ;
                                ;	Input:   A = Page Address of load top
                                ;		 H = Length in pages of module to read
                                ;
  0073'                         load::
  0073' B7                      	or	a		; Clear carry
  0074' 57                      	ld	d,a
  0075' 1E 00                   	ld	e,0
  0077' 7C                      	ld	a,h
  0078' 17                      	rla
  0079' 67                      	ld	h,a		; H = length in records of module
  007A'                         loop::
  007A' EB                      	ex	de,hl
  007B' 01 FF80                 	ld	bc,-128
  007E' 09                      	add	hl,bc		; Decrement dma address by 128
  007F' EB                      	ex	de,hl		; (boot image is loaded from top down)
  0080' D5                      	push	de
  0081' E5                      	push	hl
  0082' CD 008F'                	call	setdma$proc
  0085' CD 0095'                	call	read$proc
  0088' E1                      	pop	hl
  0089' D1                      	pop	de
  008A' 25                      	dec	h
  008B' C2 007A'                	jp	nz,loop
  008E' C9                      	ret
                                
                                ;
                                ;	Set DMA Routine
                                ;
  008F'                         setdma$proc::
  008F' 0E 1A                   	ld	c,setdma$func
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    4
CP/M V3.0 Loader

  0091' CD 018D'                	call	bdos
  0094' C9                      	ret
                                
                                ;
                                ;	Read Routine
                                ;
  0095'                         read$proc::
  0095' 0E 14                   	ld	c,read$func	; Read the load record
  0097' 11 00AB'                	ld	de,cpmfcb	; Into address 80h
  009A' CD 018D'                	call	bdos
  009D' B7                      	or	a
  009E' 11 00FA'                	ld	de,readerr
  00A1' C8                      	ret	z
                                ;
                                ;	Error Routine
                                ;
  00A2'                         error::
  00A2' 0E 09                   	ld	c,printbuf	; Print error message
  00A4' CD 018D'                	call	bdos
  00A7' F3                      	di
  00A8' 76                      	halt
                                
  00A9'                         break::
                                  ifdef halt$ldr
                                	halt
                                  else
  00A9' FF                      	rst	038h
                                  endif
  00AA' C9                      	ret
                                
  00AB'                         cpmfcb::
                                  ifdef	test
  00AB' 00 54 45 53 54 20       	defb	0,'TEST    SYS',0,0,0,0,0,0
  00B1' 20 20 20 53 59 53       
  00B7' 00 00 00 00 00 00       
                                  else
                                	defb	0,'CPM3    SYS',0,0,0,0,0,0
                                  endif
  00BD' 0000  0000  0000        	defw	0,0,0,0,0,0,0,0,0
  00C3' 0000  0000  0000        
  00C9' 0000  0000  0000        
                                
  00CF'                         openerr::
  00CF' 0D 0A                   	defb	cr,lf
  00D1' 43 50 4D 4C 44 52       	defb	'CPMLDR error:  failed to open '
  00D7' 20 65 72 72 6F 72       
  00DD' 3A 20 20 66 61 69       
  00E3' 6C 65 64 20 74 6F       
  00E9' 20 6F 70 65 6E 20       
                                  ifdef test
  00EF' 54 45 53 54             	defb	'TEST'
                                  else
                                	defb	'CPM3'
                                  endif
  00F3' 2E 53 59 53             	defb	'.SYS'
  00F7' 0D 0A 24                	defb	cr,lf,'$'
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    5
CP/M V3.0 Loader

  00FA'                         readerr::
  00FA' 0D 0A                   	defb	cr,lf
  00FC' 43 50 4D 4C 44 52       	defb	'CPMLDR error:  failed to read '
  0102' 20 65 72 72 6F 72       
  0108' 3A 20 20 66 61 69       
  010E' 6C 65 64 20 74 6F       
  0114' 20 72 65 61 64 20       
                                  ifdef test
  011A' 54 45 53 54             	defb	'TEST'
                                  else
                                	defb	'CPM3'
                                  endif
  011E' 2E 53 59 53             	defb	'.SYS'
  0122' 0D 0A 24                	defb	cr,lf,'$'
                                
                                	; leave these here to keep everything static
  0125' 0A 0A 0A 0A 0A 0A       	defb	lf,lf,lf,lf,lf,lf,lf,lf,lf,lf,lf,lf
  012B' 0A 0A 0A 0A 0A 0A       
  0131' 0A                      	defb	lf
  0132'                         signon::
  0132' 0D 0A                   	defb	cr,lf
  0134' 43 50 4D 4C 44 52       	defb	'CPMLDR3 - CP/M V3.0 Loader',cr,lf
  013A' 33 20 2D 20 43 50       
  0140' 2F 4D 20 56 33 2E       
  0146' 30 20 4C 6F 61 64       
  014C' 65 72 0D 0A             
  0150' 43 6F 70 79 72 69       	defb	'Copyright (C) 1982, Digital Research'
  0156' 67 68 74 20 28 43       
  015C' 29 20 31 39 38 32       
  0162' 2C 20 44 69 67 69       
  0168' 74 61 6C 20 52 65       
  016E' 73 65 61 72 63 68       
  0174' 0D 0A 24                	defb	cr,lf,'$'
                                
  0177' 30 32 31 31 38 32       	defb	'021182',0,0,0,0
  017D' 00 00 00 00             
                                
                                  if 0			;AGN - needs more stack-space
                                	rept	24
                                	defb	'%%%%'
                                	endm
                                  endif
                                
  0181'                         stackbot::
                                
  0181'                         mem$top::
  0181' ( 0001 )                	defs	1
  0182'                         res$len::
  0182' ( 0001 )                	defs	1
  0183'                         bank$top::
  0183' ( 0001 )                	defs	1
  0184'                         bank$len::
  0184' ( 0001 )                	defs	1
  0185'                         osentry$adr::
  0185' ( 0002 )                	defs	2
                                
                                ;	title	'CP/M 3.0 LDRBDOS Interface, Version 3.1 Nov, 1982'
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    6
CP/M V3.0 Loader

                                ;*****************************************************************
                                ;*****************************************************************
                                ;**                                                             **
                                ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                                ;**								**
                                ;**            I n t e r f a c e   M o d u l e                  **
                                ;**                                                             **
                                ;*****************************************************************
                                ;*****************************************************************
                                ;
                                ;	Copyright (c) 1978, 1979, 1980, 1981, 1982
                                ;	Digital Research
                                ;	Box 579, Pacific Grove
                                ;	California
                                ;
                                ;       Nov 1982
                                ;
                                ;
                                ;	equates for non graphic characters
                                ;
                                
  007F  =                       rubout	equ	7fh		; char delete
  0009  =                       tab	equ	09h		; tab char
  000D  =                       cr	equ	0dh		; carriage return
  000A  =                       lf	equ	0ah		; line feed
  0008  =                       ctlh	equ	08h		; backspace
                                
                                
                                ;
  0187' 00 00 00 00 00 00       serial:	defb	0,0,0,0,0,0
                                ;
                                ;	Enter here from the user's program with function number in c,
                                ;	and information address in d,e
                                ;
                                
  018D'                         bdos::
  018D'                         bdose::				; Arrive here from user programs
  018D' EB                      	ex	de,hl
  018E' 22 08DF'                	ld	(info),hl
  0191' EB                      	ex	de,hl		; info=de, de=info
                                
  0192' 79                      	ld	a,c
  0193' FE 0E                   	cp	14
  0195' DA 01A5'                	jp	c,bdose2
  0198' 32 08E2'                	ld	(fx),a		; Save disk function #
  019B' AF                      	xor	a
  019C' 32 08B7'                	ld	(dir$cnt),a
  019F' 3A 08DE'                	ld	a,(seldsk)
  01A2' 32 08BE'                	ld	(olddsk),a	; Save seldsk
                                
  01A5'                         bdose2:
  01A5' 7B                      	ld	a,e
  01A6' 32 08BA'                	ld	(linfo),a	; linfo = low(info) - don't equ
  01A9' 21 0000                 	ld	hl,0
  01AC' 22 0309'                	ld	(aret),hl	; Return value defaults to 0000
  01AF' 22 08E1'                	ld	(resel),hl	; resel = 0
                                				; Save user's stack pointer, set to local stack
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    7
CP/M V3.0 Loader

  01B2' 39                      	add	hl,sp
  01B3' 22 0240'                	ld	(entsp),hl	; entsp = stackptr
                                
  01B6' 31 0292'                	ld	sp,lstack	; local stack setup
                                
  01B9' 21 084E'                	ld	hl,goback	; Return here after all functions
  01BC' E5                      	push	hl		; jmp goback equivalent to ret
  01BD' 79                      	ld	a,c
  01BE' FE 32                   	cp	nfuncs
  01C0' D2 01CA'                	jp	nc,high$fxs	; Skip if invalid #
  01C3' 4B                      	ld	c,e		; possible output character to c
  01C4' 21 01DC'                	ld	hl,functab
  01C7' C3 01CF'                	jp	bdos$jmp
                                
                                				; look for functions 100 ->
  01CA'                         high$fxs:
  01CA' DE 64                   	sbc	a,100
  01CC' DA 069B'                	jp	c,lret$eq$ff	; Skip if function < 100
                                
  01CF'                         bdos$jmp:
                                
  01CF' 5F                      	ld	e,a
  01D0' 16 00                   	ld	d,0		; de=func, hl=.ciotab
  01D2' 19                      	add	hl,de
  01D3' 19                      	add	hl,de
  01D4' 5E                      	ld	e,(hl)
  01D5' 23                      	inc	hl
  01D6' 56                      	ld	d,(hl)		; de=functab(func)
  01D7' 2A 08DF'                	ld	hl,(info)	; info in de for later xchg	
  01DA' EB                      	ex	de,hl
  01DB' E9                      	jp	(hl)		; dispatched
                                
                                
                                ;	dispatch table for functions
                                
  01DC'                         functab:
  01DC' 02E8' 02E8' 02BB'       	defw	func$ret, func1, func2, func3
  01E2' 02E8'                   
  01E4' 02E8' 02E8' 02E8'       	defw	func$ret, func$ret, func6, func$ret
  01EA' 02E8'                   
  01EC' 02E8' 02DF' 02E8'       	defw	func$ret, func9, func10, func11
  01F2' 02E8'                   
  000C  =                       diskf	equ	($-functab)/2	; disk funcs
  01F4' 02E8' 0800' 0817'       	defw	func12,func13,func14,func15
  01FA' 081D'                   
  01FC' 02E8' 02E8' 02E8'       	defw	func16,func17,func18,func19
  0202' 02E8'                   
  0204' 083B' 02E8' 02E8'       	defw	func20,func21,func22,func23
  020A' 02E8'                   
  020C' 02E8' 0841' 0847'       	defw	func24,func25,func26,func27
  0212' 02E8'                   
  0214' 02E8' 02E8' 02E8'       	defw	func28,func29,func30,func31
  021A' 02E8'                   
  021C' 02E8' 02E8' 02E8'       	defw	func32,func33,func34,func35
  0222' 02E8'                   
  0224' 02E8' 02E8' 02E8'       	defw	func36,func37,func38,func39
  022A' 02E8'                   
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    8
CP/M V3.0 Loader

  022C' 02E8' 02E8' 02E8'       	defw	func40,func42,func43
  0232' 02E8' 02E8' 02E8'       	defw	func44,func45,func46,func47
  0238' 02E8'                   
  023A' 02E8' 02E8' 02E8'       	defw	func48,func49,func50
  0032  =                       nfuncs	equ	($-functab)/2
                                
                                
  0240' ( 0002 )                entsp:	defs	2		; entry stack pointer
                                
                                				; 	40 level stack
                                
  0242' C7C7  C7C7  C7C7        	defw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
  0248' C7C7  C7C7  C7C7        
  024E' C7C7  C7C7              
  0252' C7C7  C7C7  C7C7        	defw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
  0258' C7C7  C7C7  C7C7        
  025E' C7C7  C7C7              
  0262' C7C7  C7C7  C7C7        	defw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
  0268' C7C7  C7C7  C7C7        
  026E' C7C7  C7C7              
  0272' C7C7  C7C7  C7C7        	defw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
  0278' C7C7  C7C7  C7C7        
  027E' C7C7  C7C7              
  0282' C7C7  C7C7  C7C7        	defw	0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h,0c7c7h
  0288' C7C7  C7C7  C7C7        
  028E' C7C7  C7C7              
  0292'                         lstack:
                                
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page    9
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

                                ;*****************************************************************
                                ;*****************************************************************
                                ;**                                                             **
                                ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                                ;**								**
                                ;**               C o n s o l e   P o r t i o n                 **
                                ;**                                                             **
                                ;*****************************************************************
                                ;*****************************************************************
                                ;
                                ;       July, 1982
                                ;
                                ;
                                ;	console handlers
                                
  0292'                         conout:
                                				; Compute character position/write console char from C
                                				; Compcol = true if computing column position
  0292' 3A 02EE'                	ld	a,(compcol)
  0295' B7                      	or	a
  0296' C2 029E'                	jp	nz,compout
                                				; Write the character, then compute the column
                                				; Write console character from C
  0299' C5                      	push	bc		; Recall/save character
  029A' CD 0A0C'                	call	conoutf		; Externally, to console
  029D' C1                      	pop	bc		; Recall the character
  029E'                         compout:
  029E' 79                      	ld	a,c		; Recall the character
                                				; And compute column position
  029F' 21 08DA'                	ld	hl,column	; A = char, HL = .column
  02A2' FE 7F                   	cp	rubout
  02A4' C8                      	ret	z		; No column change if nulls
  02A5' 34                      	inc	(hl)		; Column = column + 1
  02A6' FE 20                   	cp	' '
  02A8' D0                      	ret	nc		; Return if graphic
                                				; Not graphic, reset column position
  02A9' 35                      	dec	(hl)		; Column = column - 1
  02AA' 7E                      	ld	a,(hl)
  02AB' B7                      	or	a
  02AC' C8                      	ret	z		; Return if at zero
                                				; Not at zero, may be backspace or eol
  02AD' 79                      	ld	a,c		; Character back to A
  02AE' FE 08                   	cp	ctlh
  02B0' C2 02B5'                	jp	nz,notbacksp
                                				; Backspace character
  02B3' 35                      	dec	(hl)		; Column = column - 1
  02B4' C9                      	ret
                                
  02B5'                         notbacksp:
                                				; Not a backspace character, eol?
  02B5' FE 0A                   	cp	lf
  02B7' C0                      	ret	nz		; Return if not
                                				; End of line, column = 0
  02B8' 36 00                   	ld	(hl),0		; Column = 0
  02BA' C9                      	ret
                                ;
                                ;
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   10
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  02BB'                         tabout:
                                				; Expand tabs to console
  02BB' 79                      	ld	a,c
  02BC' FE 09                   	cp	tab
  02BE' C2 0292'                	jp	nz,conout	; Direct to conout if not
                                				; Tab encountered, move to next tab pos
  02C1'                         tab0:
  02C1' 0E 20                   	ld	c,' '
  02C3' CD 0292'                	call	conout		; Another blank
  02C6' 3A 08DA'                	ld	a,(column)
  02C9' E6 07                   	and	111b		; Column mod 8 = 0 ?
  02CB' C2 02C1'                	jp	nz,tab0		; Back for another if not
  02CE' C9                      	ret
                                ;
  02CF'                         print:
                                				; Print message until M(BC) = '$'
  02CF' 21 08DB'                	ld	hl,outdelim
  02D2' 0A                      	ld	a,(bc)
  02D3' BE                      	cp	(hl)
  02D4' C8                      	ret	z		; Stop on $
                                				; More to print
  02D5' 03                      	inc	bc
  02D6' C5                      	push	bc
  02D7' 4F                      	ld	c,a		; Char to C
  02D8' CD 02BB'                	call	tabout		; Another character printed
  02DB' C1                      	pop	bc
  02DC' C3 02CF'                	jp	print
                                ;
                                ;
  02BB' =                       func2	equ	tabout
                                				; Write console character with tab expansion
                                ;
  02DF'                         func9:
                                				; Write line until $ encountered
  02DF' EB                      	ex	de,hl		; Was lhld info	
  02E0' 4D                      	ld	c,l
  02E1' 44                      	ld	b,h		; BC=string address
  02E2' C3 02CF'                	jp	print		; Out to console	
                                ;
  02E5'                         sta$ret:
                                				; Store the A register to aret
  02E5' 32 0309'                	ld	(aret),a
  02E8'                         func$ret:
  02E8' C9                      	ret			; Jmp goback (pop stack for non cp/m functions)
                                ;
  02E9'                         setlret1:
                                				; Set lret = 1
  02E9' 3E 01                   	ld	a,1
  02EB' C3 02E5'                	jp	sta$ret
                                ;
  02E8' =                       func1	equ	func$ret
                                ;
  02E8' =                       func3	equ	func$ret
                                ;
  02E8' =                       func6	equ	func$ret
                                ;
  02E8' =                       func10	equ	func$ret
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   11
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  02E8' =                       func11	equ	func$ret
                                ;
                                ;	data areas
                                ;
                                
                                
  02EE' 00                      compcol:defb	0		; True if computing column position
                                ;	end of BDOS Console module
                                
                                ;**********************************************************************
                                ;*****************************************************************
                                ;
                                ;	Error Messages
                                
  0024  =                       md	equ	24h
                                
  02EF' 0D 0A 42 44 4F 53       err$msg:defb	cr,lf,'BDOS ERR: ',md
  02F5' 20 45 52 52 3A 20       
  02FB' 24                      
  02FC'                         err$select:
  02FC' 53 65 6C 65 63 74       	defb	'Select',md
  0302' 24                      
  0303'                         err$phys:
  0303' 50 65 72 6D 2E 24       	defb	'Perm.',md
                                
                                ;*****************************************************************
                                ;*****************************************************************
                                ;
                                ;	common values shared between bdosi and bdos
                                
                                
  0309' ( 0002 )                aret:	defs	2		; address value to return
  0309' =                       lret	equ	aret		; low(aret)
                                
                                ;*****************************************************************
                                ;*****************************************************************
                                ;**                                                             **
                                ;**   b a s i c    d i s k   o p e r a t i n g   s y s t e m    **
                                ;**                                                             **
                                ;*****************************************************************
                                ;*****************************************************************
                                
                                ;	literal constants
                                
  00FF  =                       true	equ	0ffh		; constant true
  0000  =                       false	equ	000h		; constant false
  FFFF  =                       enddir	equ	0ffffh		; end of directory
  0001  =                       byte	equ	1		; number of bytes for "byte" type
  0002  =                       word	equ	2		; number of bytes for "word" type
                                
                                ;	fixed addresses in low memory
                                
  0080  =                       tbuff	equ	0080h		; default buffer location
                                
                                ;	error message handlers
                                
  030B'                         sel$error:
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   12
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

                                				; report select error
  030B' 01 02EF'                	ld	bc,err$msg
  030E' CD 02CF'                	call	print
  0311' 01 02FC'                	ld	bc,err$select
  0314' C3 0320'                	jp	goerr1
                                
  0317'                         goerr:
  0317' 01 02EF'                	ld	bc,err$msg
  031A' CD 02CF'                	call	print
  031D' 01 0303'                	ld	bc,err$phys
  0320'                         goerr1:
  0320' CD 02CF'                	call	print
  0323' F3                      	di
  0324' 76                      	halt
                                
  0325'                         bde$e$bde$m$hl:
  0325' 7B                      	ld	a,e
  0326' 95                      	sub	l
  0327' 5F                      	ld	e,a
  0328' 7A                      	ld	a,d
  0329' 9C                      	sbc	a,h
  032A' 57                      	ld	d,a
  032B' D0                      	ret	nc
  032C' 05                      	dec	b
  032D' C9                      	ret
                                
  032E'                         bde$e$bde$p$hl:
  032E' 7B                      	ld	a,e
  032F' 85                      	add	a,l
  0330' 5F                      	ld	e,a
  0331' 7A                      	ld	a,d
  0332' 8C                      	adc	a,h
  0333' 57                      	ld	d,a
  0334' D0                      	ret	nc
  0335' 04                      	inc	b
  0336' C9                      	ret
                                
  0337'                         shl3bv:
  0337' 0C                      	inc	c
  0338'                         shl3bv1:
  0338' 0D                      	dec	c
  0339' C8                      	ret	z
  033A' 29                      	add	hl,hl
  033B' 8F                      	adc	a,a
  033C' C3 0338'                	jp	shl3bv1
                                
  033F'                         compare:
  033F' 1A                      	ld	a,(de)
  0340' BE                      	cp	(hl)
  0341' C0                      	ret	nz
  0342' 23                      	inc	hl
  0343' 13                      	inc	de
  0344' 0D                      	dec	c
  0345' C8                      	ret	z
  0346' C3 033F'                	jp	compare
                                
                                ;
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   13
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

                                ;	local subroutines for bios interface
                                ;
                                
  0349'                         move:
                                				; Move data length of length c from source de to
                                				; destination given by hl
  0349' 0C                      	inc	c		; in case it is zero
  034A'                         move0:
  034A' 0D                      	dec	c
  034B' C8                      	ret	z		; more to move
  034C' 1A                      	ld	a,(de)
  034D' 77                      	ld	(hl),a		; one byte moved
  034E' 13                      	inc	de
  034F' 23                      	inc	hl		; to next byte
  0350' C3 034A'                	jp	move0
                                
  0353'                         selectdisk:
                                				; Select the disk drive given by register D, and fill
                                				; the base addresses curtrka - alloca, then fill
                                				; the values of the disk parameter block
  0353' 4A                      	ld	c,d		; current disk# to c
                                				; lsb of e = 0 if not yet logged - in
  0354' CD 0A1B'                	call	seldskf		; hl filled by call
                                				; hl = 0000 if error, otherwise disk headers
  0357' 7C                      	ld	a,h
  0358' B5                      	or	l
  0359' C8                      	ret	z		; Return with C flag reset if select error
                                				; Disk header block address in hl
  035A' 5E                      	ld	e,(hl)
  035B' 23                      	inc	hl
  035C' 56                      	ld	d,(hl)
  035D' 23                      	inc	hl		; de=.tran
  035E' 23                      	inc	hl
  035F' 23                      	inc	hl
  0360' 22 0890'                	ld	(curtrka),hl
  0363' 23                      	inc	hl
  0364' 23                      	inc	hl		; hl=.currec
  0365' 22 0892'                	ld	(curreca),hl
  0368' 23                      	inc	hl
  0369' 23                      	inc	hl		; hl=.buffa
  036A' 23                      	inc	hl
  036B' 23                      	inc	hl
  036C' 23                      	inc	hl
  036D' 23                      	inc	hl
                                				; de still contains .tran
  036E' EB                      	ex	de,hl
  036F' 22 08B8'                	ld	(tranv),hl	; .tran vector
  0372' 21 0898'                	ld	hl,dpbaddr	; de= source for move, hl=dest
  0375' 0E 0D                   	ld	c,addlist
  0377' CD 0349'                	call	move		; addlist filled
                                				; Now fill the disk parameter block
  037A' 2A 0898'                	ld	hl,(dpbaddr)
  037D' EB                      	ex	de,hl		; de is source
  037E' 21 08A5'                	ld	hl,sectpt	; hl is destination
  0381' 0E 11                   	ld	c,dpblist
  0383' CD 0349'                	call	move		; data filled
                                				; Now set single/double map mode
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   14
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0386' 2A 08AA'                	ld	hl,(maxall)	; largest allocation number
  0389' 7C                      	ld	a,h		; 00 indicates < 255
  038A' 21 08BD'                	ld	hl,single
  038D' 36 FF                   	ld	(hl),true	; Assume a=00
  038F' B7                      	or	a
  0390' CA 0395'                	jp	z,retselect
                                				; high order of maxall not zero, use double dm
  0393' 36 00                   	ld	(hl),false
  0395'                         retselect:
                                				; C flag set indicates successful select
  0395' 37                      	scf
  0396' C9                      	ret
                                
  0397'                         home:
                                				; Move to home position, then offset to start of dir
  0397' CD 0A18'                	call	homef
  039A' AF                      	xor	a		; constant zero to accumulator
  039B' 2A 0890'                	ld	hl,(curtrka)
  039E' 77                      	ld	(hl),a
  039F' 23                      	inc	hl
  03A0' 77                      	ld	(hl),a		; curtrk=0000
  03A1' 2A 0892'                	ld	hl,(curreca)
  03A4' 77                      	ld	(hl),a
  03A5' 23                      	inc	hl
  03A6' 77                      	ld	(hl),a		; currec=0000
  03A7' 23                      	inc	hl
  03A8' 77                      	ld	(hl),a		; currec high byte=00
                                
  03A9' C9                      	ret
                                
  03AA'                         pass$arecord:
  03AA' 21 08C3'                	ld	hl,arecord
  03AD' 5E                      	ld	e,(hl)
  03AE' 23                      	inc	hl
  03AF' 56                      	ld	d,(hl)
  03B0' 23                      	inc	hl
  03B1' 46                      	ld	b,(hl)
  03B2' C9                      	ret
                                
  03B3'                         rdbuff:
                                				; Read buffer and check condition
  03B3' CD 03AA'                	call	pass$arecord
  03B6' CD 0A27'                	call	readf		; current drive, track, sector, dma
                                
                                
  03B9'                         diocomp:			; Check for disk errors
  03B9' B7                      	or	a
  03BA' C8                      	ret	z
  03BB' 4F                      	ld	c,a
  03BC' FE 03                   	cp	3
  03BE' DA 0317'                	jp	c,goerr
  03C1' 0E 01                   	ld	c,1
  03C3' C3 0317'                	jp	goerr
                                
  03C6'                         seekdir:
                                				; Seek the record containing the current dir entry
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   15
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  03C6' 2A 08E3'                	ld	hl,(dcnt)	; directory counter to hl
  03C9' 0E 02                   	ld	c,dskshf
  03CB' CD 0526'                	call	hlrotr		; value to hl
                                
  03CE' 06 00                   	ld	b,0
  03D0' EB                      	ex	de,hl
                                
  03D1' 21 08C3'                	ld	hl,arecord
  03D4' 73                      	ld	(hl),e
  03D5' 23                      	inc	hl
  03D6' 72                      	ld	(hl),d
  03D7' 23                      	inc	hl
  03D8' 70                      	ld	(hl),b
  03D9' C9                      	ret
                                
  03DA'                         seek:
                                				; Seek the track given by arecord (actual record)
                                
  03DA' 2A 0890'                	ld	hl,(curtrka)
  03DD' 4E                      	ld	c,(hl)
  03DE' 23                      	inc	hl
  03DF' 46                      	ld	b,(hl)		; bc = curtrk
  03E0' C5                      	push	bc		; s0 = curtrk 
  03E1' 2A 0892'                	ld	hl,(curreca)
  03E4' 5E                      	ld	e,(hl)
  03E5' 23                      	inc	hl
  03E6' 56                      	ld	d,(hl)
  03E7' 23                      	inc	hl
  03E8' 46                      	ld	b,(hl)		; bde = currec
  03E9' 2A 08C3'                	ld	hl,(arecord)
  03EC' 3A 08C5'                	ld	a,(arecord+2)
  03EF' 4F                      	ld	c,a		; chl = arecord
  03F0'                         seek0:
  03F0' 7D                      	ld	a,l
  03F1' 93                      	sub	e
  03F2' 7C                      	ld	a,h
  03F3' 9A                      	sbc	a,d
  03F4' 79                      	ld	a,c
  03F5' 98                      	sbc	a,b
  03F6' E5                      	push	hl		; Save low(arecord)
  03F7' D2 0407'                	jp	nc,seek1	; if arecord >= currec then go to seek1
  03FA' 2A 08A5'                	ld	hl,(sectpt)
  03FD' CD 0325'                	call	bde$e$bde$m$hl	; currec = currec - sectpt
  0400' E1                      	pop	hl
  0401' E3                      	ex	(sp),hl
  0402' 2B                      	dec	hl
  0403' E3                      	ex	(sp),hl		; curtrk = curtrk - 1
  0404' C3 03F0'                	jp	seek0
  0407'                         seek1:
  0407' 2A 08A5'                	ld	hl,(sectpt)
  040A' CD 032E'                	call	bde$e$bde$p$hl	; currec = currec + sectpt
  040D' E1                      	pop	hl		; Restore low(arecord)
  040E' 7D                      	ld	a,l
  040F' 93                      	sub	e
  0410' 7C                      	ld	a,h
  0411' 9A                      	sbc	a,d
  0412' 79                      	ld	a,c
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   16
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0413' 98                      	sbc	a,b
  0414' DA 041E'                	jp	c,seek2		; if arecord < currec then go to seek2
  0417' E3                      	ex	(sp),hl
  0418' 23                      	inc	hl
  0419' E3                      	ex	(sp),hl		; curtrk = curtrk + 1
  041A' E5                      	push	hl		; save low (arecord)
  041B' C3 0407'                	jp	seek1
  041E'                         seek2:
  041E' E3                      	ex	(sp),hl
  041F' E5                      	push	hl		; hl,s0 = curtrk, s1 = low(arecord)
  0420' 2A 08A5'                	ld	hl,(sectpt)
  0423' CD 0325'                	call	bde$e$bde$m$hl	; currec = currec - sectpt
  0426' E1                      	pop	hl
  0427' D5                      	push	de
  0428' C5                      	push	bc
  0429' E5                      	push	hl		; hl,s0 = curtrk, 
                                				; s1 = high(arecord,currec), s2 = low(currec), 
                                				; s3 = low(arecord)
  042A' EB                      	ex	de,hl
  042B' 2A 08B2'                	ld	hl,(offset)
  042E' 19                      	add	hl,de
  042F' 44                      	ld	b,h
  0430' 4D                      	ld	c,l
  0431' 22 08CE'                	ld	(track),hl
  0434' CD 0A1E'                	call	settrkf		; call bios settrk routine
                                				; Store curtrk
  0437' D1                      	pop	de
  0438' 2A 0890'                	ld	hl,(curtrka)
  043B' 73                      	ld	(hl),e
  043C' 23                      	inc	hl
  043D' 72                      	ld	(hl),d
                                				; Store currec
  043E' C1                      	pop	bc
  043F' D1                      	pop	de
                                
  0440' 2A 0892'                	ld	hl,(curreca)
  0443' 73                      	ld	(hl),e
  0444' 23                      	inc	hl
  0445' 72                      	ld	(hl),d
  0446' 23                      	inc	hl
  0447' 70                      	ld	(hl),b		; currec = bde
  0448' C1                      	pop	bc		; bc = low(arecord), de = low(currec)
  0449' 79                      	ld	a,c
  044A' 93                      	sub	e
  044B' 6F                      	ld	l,a		; hl = bc - de
  044C' 78                      	ld	a,b
  044D' 9A                      	sbc	a,d
  044E' 67                      	ld	h,a
  044F' CD 046B'                	call	shr$physhf
  0452' 44                      	ld	b,h
  0453' 4D                      	ld	c,l
                                
  0454' 2A 08B8'                	ld	hl,(tranv)
  0457' EB                      	ex	de,hl		; bc=sector#, de=.tran
  0458' CD 0A30'                	call	sectran		; hl = tran(sector)
  045B' 4D                      	ld	c,l
  045C' 44                      	ld	b,h		; bc = tran(sector)
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   17
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  045D' 22 08D0'                	ld	(sector),hl
  0460' CD 0A21'                	call	setsecf		; sector selected
  0463' 2A 088A'                	ld	hl,(curdma)
  0466' 4D                      	ld	c,l
  0467' 44                      	ld	b,h
  0468' C3 0A24'                	jp	setdmaf
                                
  046B'                         shr$physhf:
  046B' 3A 08B4'                	ld	a,(physhf)
  046E' 4F                      	ld	c,a
  046F' C3 0526'                	jp	hlrotr
                                
                                
                                ;	file control block (fcb) constants
                                
  00E5  =                       empty	equ	0e5h		; empty directory entry
  0080  =                       recsiz	equ	128		; record size
  0020  =                       fcblen	equ	32		; file control block size
  0004  =                       dirrec	equ	recsiz/fcblen	; directory fcbs / record
  0002  =                       dskshf	equ	2		; log2(dirrec)
  0003  =                       dskmsk	equ	dirrec-1
  0005  =                       fcbshf	equ	5		; log2(fcblen)
                                
  000C  =                       extnum	equ	12		; extent number field
  001F  =                       maxext	equ	31		; largest extent number
  000D  =                       ubytes	equ	13		; unfilled bytes field
                                
  000F  =                       namlen	equ	15		; name length
  000F  =                       reccnt	equ	15		; record count field
  0010  =                       dskmap	equ	16		; disk map field
  0020  =                       nxtrec	equ	fcblen
                                
                                ;	utility functions for file access
                                
  0472'                         dm$position:
                                				; Compute disk map position for vrecord to hl
  0472' 21 08A7'                	ld	hl,blkshf
  0475' 4E                      	ld	c,(hl)		; shift count to c
  0476' 3A 08C1'                	ld	a,(vrecord)	; current virtual record to a
  0479'                         dmpos0:
  0479' B7                      	or	a
  047A' 1F                      	rra
  047B' 0D                      	dec	c
  047C' C2 0479'                	jp	nz,dmpos0
                                				; a = shr(vrecord,blkshf) = vrecord/2**(sect/block)
  047F' 47                      	ld	b,a		; Save it for later addition
  0480' 3E 08                   	ld	a,8
  0482' 96                      	sub	(hl)		; 8-blkshf to accumulator
  0483' 4F                      	ld	c,a		; extent shift count in register c
  0484' 3A 08C0'                	ld	a,(extval)	; extent value ani extmsk
  0487'                         dmpos1:
                                				; blkshf = 3,4,5,6,7, c=5,4,3,2,1
                                				; shift is 4,3,2,1,0
  0487' 0D                      	dec	c
  0488' CA 0490'                	jp	z,dmpos2
  048B' B7                      	or	a
  048C' 17                      	rla
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   18
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  048D' C3 0487'                	jp	dmpos1
  0490'                         dmpos2:
                                				; Arrive here with a = shl(ext and extmsk,7-blkshf)
  0490' 80                      	add	a,b		; Add the previous shr(vrecord,blkshf) value
                                				; a is one of the following values, depending upon alloc
                                				; bks blkshf
                                				; 1k   3     v/8 + extval * 16
                                				; 2k   4     v/16+ extval * 8
                                				; 4k   5     v/32+ extval * 4
                                				; 8k   6     v/64+ extval * 2
                                				; 16k  7     v/128+extval * 1
  0491' C9                      	ret			; with dm$position in a
                                
  0492'                         getdma:
  0492' 2A 08DF'                	ld	hl,(info)
  0495' 11 0010                 	ld	de,dskmap
  0498' 19                      	add	hl,de
  0499' C9                      	ret
                                
  049A'                         getdm:
                                				; Return disk map value from position given by bc
  049A' CD 0492'                	call	getdma
  049D' 09                      	add	hl,bc		; Index by a single byte value
  049E' 3A 08BD'                	ld	a,(single)	; single byte/map entry?
  04A1' B7                      	or	a
  04A2' CA 04A8'                	jp	z,getdmd	; Get disk map single byte
  04A5' 6E                      	ld	l,(hl)
  04A6' 60                      	ld	h,b
  04A7' C9                      	ret			; with hl=00bb
  04A8'                         getdmd:
  04A8' 09                      	add	hl,bc		; hl=.fcb(dm+i*2)
                                				; double precision value returned
  04A9' 7E                      	ld	a,(hl)
  04AA' 23                      	inc	hl
  04AB' 66                      	ld	h,(hl)
  04AC' 6F                      	ld	l,a
  04AD' C9                      	ret
                                
  04AE'                         index:
                                				; Compute disk block number from current fcb
  04AE' CD 0472'                	call	dm$position	; 0...15 in register a
  04B1' 32 08BB'                	ld	(dminx),a
  04B4' 4F                      	ld	c,a
  04B5' 06 00                   	ld	b,0
  04B7' CD 049A'                	call	getdm		; value to hl
  04BA' 22 08C3'                	ld	(arecord),hl
  04BD' 7D                      	ld	a,l
  04BE' B4                      	or	h
  04BF' C9                      	ret
                                
  04C0'                         atran:
                                				; Compute actual record address, assuming index called
                                
                                ;	arecord = shl(arecord,blkshf)
                                
  04C0' 3A 08A7'                	ld	a,(blkshf)
  04C3' 4F                      	ld	c,a
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   19
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  04C4' 2A 08C3'                	ld	hl,(arecord)
  04C7' AF                      	xor	a
  04C8' CD 0337'                	call	shl3bv
  04CB' 22 08C3'                	ld	(arecord),hl
  04CE' 32 08C5'                	ld	(arecord+2),a
                                
  04D1' 22 08C6'                	ld	(arecord1),hl	; Save low(arecord)
                                
                                ;	arecord = arecord or (vrecord and blkmsk)
                                
  04D4' 3A 08A8'                	ld	a,(blkmsk)
  04D7' 4F                      	ld	c,a
  04D8' 3A 08C1'                	ld	a,(vrecord)
  04DB' A1                      	and	c
  04DC' 47                      	ld	b,a		; Save vrecord & blkmsk in reg b & blk$off
  04DD' 32 08B6'                	ld	(blk$off),a
  04E0' 21 08C3'                	ld	hl,arecord
  04E3' B6                      	or	(hl)
  04E4' 77                      	ld	(hl),a
  04E5' C9                      	ret
                                
                                
  04E6'                         getexta:
                                				; Get current extent field address to hl
  04E6' 2A 08DF'                	ld	hl,(info)
  04E9' 11 000C                 	ld	de,extnum
  04EC' 19                      	add	hl,de		; hl=.fcb(extnum)
  04ED' C9                      	ret
                                
  04EE'                         getrcnta:
                                				; Get reccnt address to hl
  04EE' 2A 08DF'                	ld	hl,(info)
  04F1' 11 000F                 	ld	de,reccnt
  04F4' 19                      	add	hl,de
  04F5' C9                      	ret
                                
  04F6'                         getfcba:
                                				; Compute reccnt and nxtrec addresses for get/setfcb
  04F6' CD 04EE'                	call	getrcnta
  04F9' EB                      	ex	de,hl		; de=.fcb(reccnt)
  04FA' 21 0011                 	ld	hl,nxtrec-reccnt
  04FD' 19                      	add	hl,de		; hl=.fcb(nxtrec) 
  04FE' C9                      	ret
                                
  04FF'                         getfcb:
                                				; Set variables from currently addressed fcb
  04FF' CD 04F6'                	call	getfcba		; addresses in de, hl
  0502' 7E                      	ld	a,(hl)
  0503' 32 08C1'                	ld	(vrecord),a	; vrecord=fcb(nxtrec)
  0506' EB                      	ex	de,hl
  0507' 7E                      	ld	a,(hl)
  0508' 32 08BF'                	ld	(rcount),a	; rcount=fcb(reccnt)
  050B' CD 04E6'                	call	getexta		; hl=.fcb(extnum)
  050E' 3A 08A9'                	ld	a,(extmsk)	; extent mask to a
  0511' A6                      	and	(hl)		; fcb(extnum) and extmsk
  0512' 32 08C0'                	ld	(extval),a
  0515' C9                      	ret
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   20
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

                                
  0516'                         setfcb:
                                				; Place values back into current fcb
  0516' CD 04F6'                	call	getfcba		; addresses to de, hl
  0519' 0E 01                   	ld	c,1
                                
  051B' 3A 08C1'                	ld	a,(vrecord)
  051E' 81                      	add	a,c
  051F' 77                      	ld	(hl),a		; fcb(nxtrec)=vrecord+seqio
  0520' EB                      	ex	de,hl
  0521' 3A 08BF'                	ld	a,(rcount)
  0524' 77                      	ld	(hl),a		; fcb(reccnt)=rcount
  0525' C9                      	ret
                                
  0526'                         hlrotr:
                                				; hl rotate right by amount c
  0526' 0C                      	inc	c		; in case zero
  0527' 0D                      hlrotr0:dec	c
  0528' C8                      	ret	z		; return when zero
                                
  0529' 7C                      	ld	a,h
  052A' B7                      	or	a
  052B' 1F                      	rra
  052C' 67                      	ld	h,a		; high byte
  052D' 7D                      	ld	a,l
  052E' 1F                      	rra
  052F' 6F                      	ld	l,a		; low byte
  0530' C3 0527'                	jp	hlrotr0
                                
  0533'                         hlrotl:
                                				; Rotate the mask in hl by amount in c
  0533' 0C                      	inc	c		; may be zero
  0534' 0D                      hlrotl0:dec	c
  0535' C8                      	ret	z		; return if zero
                                
  0536' 29                      	add	hl,hl
  0537' C3 0534'                	jp	hlrotl0
                                
  053A'                         set$cdisk:
                                				; Set a "1" value in curdsk position of bc
  053A' 3A 08DE'                	ld	a,(seldsk)
  053D' C5                      	push	bc		; Save input parameter
  053E' 4F                      	ld	c,a		; Ready parameter for shift
  053F' 21 0001                 	ld	hl,1		; number to shift
  0542' CD 0533'                	call	hlrotl		; hl = mask to integrate
  0545' C1                      	pop	bc		; original mask
  0546' 79                      	ld	a,c
  0547' B5                      	or	l
  0548' 6F                      	ld	l,a
  0549' 78                      	ld	a,b
  054A' B4                      	or	h
  054B' 67                      	ld	h,a		; hl = mask or rol(1,curdsk)
  054C' C9                      	ret
                                
  054D'                         test$vector:
  054D' 3A 08DE'                	ld	a,(seldsk)
  0550' 4F                      	ld	c,a
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   21
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0551' CD 0526'                	call	hlrotr
  0554' 7D                      	ld	a,l
  0555' E6 01                   	and	1b
  0557' C9                      	ret			; non zero if curdsk bit on
                                
  0558'                         getdptra:
                                				; Compute the address of a directory element at
                                				; positon dptr in the buffer
                                
  0558' 2A 088C'                	ld	hl,(buffa)
  055B' 3A 08C9'                	ld	a,(dptr)
                                				; hl = hl + a
  055E' 85                      	add	a,l
  055F' 6F                      	ld	l,a
  0560' D0                      	ret	nc
                                				; overflow to h
  0561' 24                      	inc	h
  0562' C9                      	ret
                                
  0563'                         clr$ext:
                                				; fcb ext = fcb ext & 1fh
                                
  0563' CD 04E6'                	call	getexta
  0566' 7E                      	ld	a,(hl)
  0567' E6 1F                   	and	00011111b
  0569' 77                      	ld	(hl),a
                                
  056A' C9                      	ret
                                
                                
  056B'                         subdh:
                                				; Compute hl = de - hl
  056B' 7B                      	ld	a,e
  056C' 95                      	sub	l
  056D' 6F                      	ld	l,a
  056E' 7A                      	ld	a,d
  056F' 9C                      	sbc	a,h
  0570' 67                      	ld	h,a
  0571' C9                      	ret
                                
  0572'                         getbuffa:
  0572' D5                      	push	de
  0573' 11 000A                 	ld	de,10
  0576' 19                      	add	hl,de
  0577' 5E                      	ld	e,(hl)
  0578' 23                      	inc	hl
  0579' 56                      	ld	d,(hl)
  057A' EB                      	ex	de,hl
  057B' D1                      	pop	de
  057C' C9                      	ret
                                
                                
  057D'                         rd$dir:
                                				; Read a directory entry into the directory buffer
  057D' CD 03C6'                	call	seekdir
  0580' 3A 08B5'                	ld	a,(phymsk)
  0583' B7                      	or	a
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   22
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0584' CA 058F'                	jp	z,rddir1
  0587' 3E 03                   	ld	a,3
  0589' CD 08E8'                	call	deblock$dir
  058C' C3 059B'                	jp	setdata
                                
  058F'                         rddir1:
  058F' CD 05A1'                	call	setdir		; directory dma
  0592' 22 088C'                	ld	(buffa),hl
  0595' CD 03DA'                	call	seek
  0598' CD 03B3'                	call	rdbuff		; directory record loaded
                                
  059B'                         setdata:
                                				; Set data dma address
  059B' 2A 08DC'                	ld	hl,(dmaad)
  059E' C3 05A7'                	jp	setdma		; to complete the call
                                
  05A1'                         setdir:
                                				; Set directory dma address
                                
  05A1' 2A 089E'                	ld	hl,(dirbcba)
  05A4' CD 0572'                	call	getbuffa
                                
  05A7'                         setdma:
                                				; hl=.dma address to set (i.e., buffa or dmaad)
  05A7' 22 088A'                	ld	(curdma),hl
  05AA' C9                      	ret
                                
  05AB'                         end$of$dir:
                                				; Return zero flag if at end of directory, non zero
                                				; if not at end (end of dir if dcnt = 0ffffh)
  05AB' 21 08E3'                	ld	hl,dcnt
  05AE' 7E                      	ld	a,(hl)		; may be 0ffh
  05AF' 23                      	inc	hl
  05B0' BE                      	cp	(hl)		; low(dcnt) = high(dcnt)?
  05B1' C0                      	ret	nz		; non zero returned if different
                                				; high and low the same, = 0ffh?
  05B2' 3C                      	inc	a		; 0ffh becomes 00 if so
  05B3' C9                      	ret
                                
  05B4'                         set$end$dir:
                                				; Set dcnt to the end of the directory
  05B4' 21 FFFF                 	ld	hl,enddir
  05B7' 22 08E3'                	ld	(dcnt),hl
  05BA' C9                      	ret
                                
                                
  05BB'                         read$dir:
                                				; Read next directory entry, with c=true if initializing
                                
  05BB' 2A 08AC'                	ld	hl,(dirmax)
  05BE' EB                      	ex	de,hl		; in preparation for subtract
  05BF' 2A 08E3'                	ld	hl,(dcnt)
  05C2' 23                      	inc	hl
  05C3' 22 08E3'                	ld	(dcnt),hl	; dcnt=dcnt+1
                                
                                				; while(dirmax >= dcnt)
  05C6' CD 056B'                	call	subdh		; de-hl
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   23
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  05C9' DA 05B4'                	jp	c,set$end$dir
                                				; not at end of directory, seek next element
                                				; initialization flag is in c
                                
  05CC' 3A 08E3'                	ld	a,(dcnt)
  05CF' E6 03                   	and	dskmsk		; low(dcnt) and dskmsk
  05D1' 06 05                   	ld	b,fcbshf	; to multiply by fcb size
                                
  05D3'                         read$dir1:
  05D3' 87                      	add	a,a
  05D4' 05                      	dec	b
  05D5' C2 05D3'                	jp	nz,read$dir1
                                				; a = (low(dcnt) and dskmsk) shl fcbshf
  05D8' 32 08C9'                	ld	(dptr),a	; ready for next dir operation
  05DB' B7                      	or	a
  05DC' C0                      	ret	nz		; Return if not a new record
                                
  05DD' C5                      	push	bc		; Save initialization flag c
  05DE' CD 057D'                	call	rd$dir		; Read the directory record
  05E1' C1                      	pop	bc		; Recall initialization flag
  05E2' C9                      	ret
  05E3'                         compext:
                                				; Compare extent# in a with that in c, return nonzero
                                				; if they do not match
  05E3' C5                      	push	bc		; Save c's original value
  05E4' F5                      	push	af
  05E5' 3A 08A9'                	ld	a,(extmsk)
  05E8' 2F                      	cpl
  05E9' 47                      	ld	b,a
                                				; b has negated form of extent mask
  05EA' 79                      	ld	a,c
  05EB' A0                      	and	b
  05EC' 4F                      	ld	c,a		; low bits removed from c
  05ED' F1                      	pop	af
  05EE' A0                      	and	b		; low bits removed from a
  05EF' 91                      	sub	c
  05F0' E6 1F                   	and	maxext		; Set flags
  05F2' C1                      	pop	bc		; Restore original values
  05F3' C9                      	ret
                                
  05F4'                         get$dir$ext:
                                				; Compute directory extent from fcb
                                				; Scan fcb disk map backwards
  05F4' CD 04F6'                	call	getfcba		; hl = .fcb(vrecord)
  05F7' 0E 10                   	ld	c,16
  05F9' 41                      	ld	b,c
  05FA' 0C                      	inc	c
  05FB' C5                      	push	bc
                                				; b=dskmap pos (rel to 0)
  05FC'                         get$de0:
  05FC' C1                      	pop	bc
  05FD' 0D                      	dec	c
  05FE' AF                      	xor	a		; Compare to zero
  05FF'                         get$de1:
  05FF' 2B                      	dec	hl
  0600' 05                      	dec	b		; Decr dskmap position
  0601' BE                      	cp	(hl)
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   24
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0602' C2 0609'                	jp	nz,get$de2	; fcb(dskmap(b)) ~= 0
  0605' 0D                      	dec	c
  0606' C2 05FF'                	jp	nz,get$de1
                                				; c = 0 -> all blocks = 0 in fcb disk map
  0609'                         get$de2:
  0609' 79                      	ld	a,c
  060A' 32 08BB'                	ld	(dminx),a
  060D' 3A 08BD'                	ld	a,(single)
  0610' B7                      	or	a
  0611' 78                      	ld	a,b
  0612' C2 0616'                	jp	nz,get$de3
  0615' 1F                      	rra			; not single, divide blk idx by 2
  0616'                         get$de3:
  0616' C5                      	push	bc
  0617' E5                      	push	hl		; Save dskmap position & count
  0618' 6F                      	ld	l,a
  0619' 26 00                   	ld	h,0		; hl = non-zero blk idx
                                				; Compute ext offset from last non-zero
                                				; block index by shifting blk idx right
                                				; 7 - blkshf
  061B' 3A 08A7'                	ld	a,(blkshf)
  061E' 57                      	ld	d,a
  061F' 3E 07                   	ld	a,7
  0621' 92                      	sub	d
  0622' 4F                      	ld	c,a
  0623' CD 0526'                	call	hlrotr
  0626' 45                      	ld	b,l
                                				; b = ext offset
  0627' 3A 08A9'                	ld	a,(extmsk)
  062A' B8                      	cp	b
  062B' E1                      	pop	hl
  062C' DA 05FC'                	jp	c,get$de0
                                				; Verify computed extent offset <= extmsk
  062F' CD 04E6'                	call	getexta
  0632' 4E                      	ld	c,(hl)
  0633' 2F                      	cpl
  0634' E6 1F                   	and	maxext
  0636' A1                      	and	c
  0637' B0                      	or	b
                                				; dir ext = (fcb ext & (~ extmsk) & maxext) | ext offset
  0638' C1                      	pop	bc		; Restore stack
  0639' C9                      	ret			; a = directory extent
                                
                                
  063A'                         search:
                                				; Search for directory element of length c at info
  063A' 2A 08DF'                	ld	hl,(info)
  063D' 22 08E5'                	ld	(searcha),hl	; searcha = info
  0640' 79                      	ld	a,c
  0641' 32 08E7'                	ld	(searchl),a	; searchl = c
                                
  0644' CD 05B4'                	call	set$end$dir	; dcnt = enddir
  0647' CD 0397'                	call	home		; to start at the beginning
                                
  064A'                         searchn:
                                				; Search for the next directory element, assuming
                                				; a previous call on search which sets searcha and
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   25
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

                                				; searchl
                                
  064A' 0E 00                   	ld	c,false
  064C' CD 05BB'                	call	read$dir	; Read next dir element
  064F' CD 05AB'                	call	end$of$dir
  0652' CA 069B'                	jp	z,lret$eq$ff
                                				; not end of directory, scan for match
  0655' 2A 08E5'                	ld	hl,(searcha)
  0658' EB                      	ex	de,hl		; de=beginning of user fcb
                                
  0659' CD 0558'                	call	getdptra	; hl = buffa+dptr
  065C' 3A 08E7'                	ld	a,(searchl)
  065F' 4F                      	ld	c,a		; length of search to c
  0660' 06 00                   	ld	b,0		; b counts up, c counts down
                                
  0662' 7E                      	ld	a,(hl)
  0663' FE E5                   	cp	empty
  0665' CA 064A'                	jp	z,searchn
                                
  0668'                         searchloop:
  0668' 79                      	ld	a,c
  0669' B7                      	or	a
  066A' CA 0694'                	jp	z,endsearch
                                				; Scan next character if not ubytes
  066D' 78                      	ld	a,b
  066E' FE 0D                   	cp	ubytes
  0670' CA 068D'                	jp	z,searchok
                                				; not the ubytes field, extent field?
  0673' FE 0C                   	cp	extnum		; may be extent field
  0675' CA 0682'                	jp	z,searchext	; Skip to search extent
  0678' 1A                      	ld	a,(de)
  0679' 96                      	sub	(hl)
  067A' E6 7F                   	and	7fh		; Mask-out flags/extent modulus
  067C' C2 064A'                	jp	nz,searchn	; Skip if not matched
  067F' C3 068D'                	jp	searchok	; matched character
  0682'                         searchext:
  0682' 1A                      	ld	a,(de)
                                				; Attempt an extent # match
  0683' C5                      	push	bc		; Save counters
  0684' 4E                      	ld	c,(hl)		; directory character to c
  0685' CD 05E3'                	call	compext		; Compare user/dir char
  0688' C1                      	pop	bc		; Recall counters
  0689' B7                      	or	a		; Set flag
  068A' C2 064A'                	jp	nz,searchn	; Skip if no match
  068D'                         searchok:
                                				; current character matches
  068D' 13                      	inc	de
  068E' 23                      	inc	hl
  068F' 04                      	inc	b
  0690' 0D                      	dec	c
  0691' C3 0668'                	jp	searchloop
  0694'                         endsearch:
                                				; entire name matches, return dir position
  0694' AF                      	xor	a
  0695' 32 0309'                	ld	(lret),a	; lret = 0
                                				; successful search -
                                				; return with zero flag reset
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   26
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0698' 47                      	ld	b,a
  0699' 04                      	inc	b
  069A' C9                      	ret
  069B'                         lret$eq$ff:
                                				; unsuccessful search -
                                				; return with zero flag set
                                				; lret,low(aret) = 0ffh
  069B' 3E FF                   	ld	a,255
  069D' 47                      	ld	b,a
  069E' 04                      	inc	b
  069F' C3 02E5'                	jp	sta$ret
                                
  06A2'                         open:
                                				; Search for the directory entry, copy to fcb
  06A2' 0E 0F                   	ld	c,namlen
  06A4' CD 063A'                	call	search
  06A7' C8                      	ret	z		; Return with lret=255 if end
                                
                                				; not end of directory, copy fcb information
  06A8'                         open$copy:
  06A8' CD 04E6'                	call	getexta
  06AB' 7E                      	ld	a,(hl)
  06AC' F5                      	push	af		; save extent to check for extent
                                				; folding - move moves entire dir FCB
  06AD' CD 0558'                	call	getdptra
  06B0' EB                      	ex	de,hl		; hl = .buff(dptr)
  06B1' 2A 08DF'                	ld	hl,(info)	; hl=.fcb(0)
  06B4' 0E 20                   	ld	c,nxtrec	; length of move operation
  06B6' CD 0349'                	call	move		; from .buff(dptr) to .fcb(0)
                                
                                				; Note that entire fcb is copied, including indicators
                                
  06B9' CD 05F4'                	call	get$dir$ext
  06BC' 4F                      	ld	c,a
  06BD' F1                      	pop	af
  06BE' 77                      	ld	(hl),a		; restore extent
                                
                                				; hl = .user extent#, c = dir extent#
                                				; above move set fcb(reccnt) to dir(reccnt)
                                				; if fcb ext < dir ext then fcb(reccnt) = fcb(reccnt) | 128
                                				; if fcb ext = dir ext then fcb(reccnt) = fcb(reccnt)
                                				; if fcb ext > dir ext then fcb(reccnt) = 0
                                
  06BF'                         set$rc:				; hl=.fcb(ext), c=dirext
  06BF' 06 00                   	ld	b,0
  06C1' EB                      	ex	de,hl
  06C2' 21 0003                 	ld	hl,reccnt-extnum
  06C5' 19                      	add	hl,de
  06C6' 1A                      	ld	a,(de)
  06C7' 91                      	sub	c
  06C8' CA 06D8'                	jp	z,set$rc2
  06CB' 78                      	ld	a,b
  06CC' D2 06D2'                	jp	nc,set$rc1
  06CF' 3E 80                   	ld	a,128
  06D1' 46                      	ld	b,(hl)
                                
  06D2'                         set$rc1:
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   27
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  06D2' 77                      	ld	(hl),a
  06D3' 78                      	ld	a,b
  06D4' 32 08BC'                	ld	(actual$rc),a
  06D7' C9                      	ret
  06D8'                         set$rc2:
  06D8' 32 08BC'                	ld	(actual$rc),a
  06DB' 7E                      	ld	a,(hl)
  06DC' B7                      	or	a
  06DD' C0                      	ret	nz		; ret if rc ~= 0
  06DE' 3A 08BB'                	ld	a,(dminx)
  06E1' B7                      	or	a
  06E2' C8                      	ret	z		; ret if no blks in fcb
  06E3' 3A 08E2'                	ld	a,(fx)
  06E6' FE 0F                   	cp	15
  06E8' C8                      	ret	z		; ret if fx = 15
  06E9' 36 80                   	ld	(hl),128	; rc = 128
  06EB' C9                      	ret
                                
  06EC'                         restore$rc:
                                				; hl = .fcb(extnum)
                                				; if actual$rc ~= 0 then rcount = actual$rc
  06EC' E5                      	push	hl
  06ED' 3A 08BC'                	ld	a,(actual$rc)
  06F0' B7                      	or	a
  06F1' CA 06FD'                	jp	z,restore$rc1
  06F4' 11 0003                 	ld	de,reccnt-extnum
  06F7' 19                      	add	hl,de
  06F8' 77                      	ld	(hl),a
  06F9' AF                      	xor	a
  06FA' 32 08BC'                	ld	(actual$rc),a
                                
  06FD'                         restore$rc1:
  06FD' E1                      	pop	hl
  06FE' C9                      	ret
                                
  06FF'                         open$reel:
                                				; Close the current extent, and open the next one
                                				; if possible.
                                
  06FF' CD 04E6'                	call	getexta
  0702' 7E                      	ld	a,(hl)
  0703' 4F                      	ld	c,a
  0704' 0C                      	inc	c
  0705' CD 05E3'                	call	compext
  0708' CA 0721'                	jp	z,open$reel3
                                
  070B' 3E 1F                   	ld	a,maxext
  070D' A1                      	and	c
  070E' 77                      	ld	(hl),a		; Incr extent field
  070F' 0E 0F                   	ld	c,namlen
  0711' CD 063A'                	call	search		; Next extent found?
                                				; not end of file, open
  0714' CD 06A8'                	call	open$copy
                                
  0717'                         open$reel2:
  0717' CD 04FF'                	call	getfcb		; Set parameters
  071A' AF                      	xor	a
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   28
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  071B' 32 08C1'                	ld	(vrecord),a
  071E' C3 02E5'                	jp	sta$ret		; lret = 0
  0721'                         open$reel3:
  0721' 34                      	inc	(hl)		; fcb(ex) = fcb(ex) + 1
  0722' CD 05F4'                	call	get$dir$ext
  0725' 4F                      	ld	c,a
                                				; Is new extent beyond dir$ext?
  0726' BE                      	cp	(hl)
  0727' D2 072E'                	jp	nc,open$reel4	; no
  072A' 35                      	dec	(hl)		; fcb(ex) = fcb(ex) - 1
  072B' C3 02E9'                	jp	setlret1
  072E'                         open$reel4:
  072E' CD 06EC'                	call	restore$rc
  0731' CD 06BF'                	call	set$rc
  0734' C3 0717'                	jp	open$reel2
                                
  0737'                         seqdiskread:
                                				; Sequential disk read operation
                                				; Read the next record from the current fcb
                                
  0737' CD 04FF'                	call	getfcb		; sets parameters for the read
                                
  073A' 3A 08C1'                	ld	a,(vrecord)
  073D' 21 08BF'                	ld	hl,rcount
  0740' BE                      	cp	(hl)		; vrecord-rcount
                                				; Skip if rcount > vrecord
  0741' DA 0753'                	jp	c,recordok
                                
                                				; not enough records in the extent
                                				; record count must be 128 to continue
  0744' FE 80                   	cp	128		; vrecord = 128?
  0746' C2 02E9'                	jp	nz,setlret1	; Skip if vrecord<>128
  0749' CD 06FF'                	call	open$reel	; Go to next extent if so
                                				; Check for open ok
  074C' 3A 0309'                	ld	a,(lret)
  074F' B7                      	or	a
  0750' C2 02E9'                	jp	nz,setlret1	; Stop at eof
                                
  0753'                         recordok:
                                				; Arrive with fcb addressing a record to read
                                
  0753' CD 04AE'                	call	index		; Z flag set if arecord = 0
                                
  0756' CA 02E9'                	jp	z,setlret1	; Reading unwritten data
                                
                                				; Record has been allocated
  0759' CD 04C0'                	call	atran		; arecord now a disk address
                                
  075C' 3A 08B5'                	ld	a,(phymsk)
  075F' B7                      	or	a		; if not 128 byte sectors
  0760' C2 08D2'                	jp	nz,read$deblock	; go to deblock
                                
  0763' CD 059B'                	call	setdata		; Set curdma = dmaad
  0766' CD 03DA'                	call	seek		; Set up for read
  0769' CD 03B3'                	call	rdbuff		; Read into (curdma)
  076C' C3 0516'                	jp	setfcb		; Update FCB
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   29
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  076F'                         curselect:
  076F' 3A 08DE'                	ld	a,(seldsk)
  0772' 3C                      	inc	a
  0773' CA 030B'                	jp	z,sel$error
  0776' 3D                      	dec	a
  0777' 21 08C2'                	ld	hl,curdsk
  077A' BE                      	cp	(hl)
  077B' C8                      	ret	z
                                
                                				; Skip if seldsk = curdsk, fall into select
  077C'                         select:
                                				; Select disk info for subsequent input or output ops
  077C' 77                      	ld	(hl),a		; curdsk = seldsk
                                
  077D' 57                      	ld	d,a		; Save seldsk in register D for selectdisk call
  077E' 2A 0888'                	ld	hl,(dlog)
  0781' CD 054D'                	call	test$vector	; test$vector does not modify DE
  0784' 5F                      	ld	e,a
  0785' D5                      	push	de		; Send to seldsk, save for test below
  0786' CD 0353'                	call	selectdisk
  0789' E1                      	pop	hl		; Recall dlog vector
  078A' D2 030B'                	jp	nc,sel$error	; returns with C flag set if select ok
                                				; Is the disk logged in?
  078D' 2D                      	dec	l		; reg l = 1 if so
  078E' C8                      	ret	z		; yes - drive previously logged in
                                
  078F' 2A 0888'                	ld	hl,(dlog)
  0792' 4D                      	ld	c,l
  0793' 44                      	ld	b,h		; call ready
  0794' CD 053A'                	call	set$cdisk
  0797' 22 0888'                	ld	(dlog),hl	; dlog=set$cdisk(dlog)
  079A' C9                      	ret
                                
  079B'                         set$seldsk:
  079B' 3A 08BA'                	ld	a,(linfo)
  079E' 32 08DE'                	ld	(seldsk),a
  07A1' C9                      	ret
                                
  07A2'                         reselectx:
  07A2' AF                      	xor	a
  07A3' 32 08C8'                	ld	(high$ext),a
  07A6' C3 07D2'                	jp	reselect1
  07A9'                         reselect:
                                				; Check current fcb to see if reselection necessary
  07A9' 3E 80                   	ld	a,80h
  07AB' 47                      	ld	b,a
  07AC' 3D                      	dec	a
  07AD' 4F                      	ld	c,a		; b = 80h, c = 7fh
  07AE' 2A 08DF'                	ld	hl,(info)
  07B1' 11 0007                 	ld	de,7
  07B4' EB                      	ex	de,hl
  07B5' 19                      	add	hl,de
  07B6' 7E                      	ld	a,(hl)
  07B7' A0                      	and	b
                                				; fcb(7) = fcb(7) & 7fh
  07B8' 7E                      	ld	a,(hl)
  07B9' A1                      	and	c
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   30
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  07BA' 77                      	ld	(hl),a
                                				; high$ext = 80h & fcb(8)
  07BB' 23                      	inc	hl
  07BC' 7E                      	ld	a,(hl)
  07BD' A0                      	and	b
  07BE' 32 08C8'                	ld	(high$ext),a
                                				; fcb(8) = fcb(8) & 7fh
  07C1' 7E                      	ld	a,(hl)
  07C2' A1                      	and	c
  07C3' 77                      	ld	(hl),a
                                				; fcb(ext) = fcb(ext) & 1fh
  07C4' CD 0563'                	call	clr$ext
                                
                                				; if fcb(rc) & 80h 
                                				;    then fcb(rc) = 80h, actual$rc = fcb(rc) & 7fh
                                				;    else actual$rc = 0
                                
  07C7' CD 04EE'                	call	getrcnta
  07CA' 7E                      	ld	a,(hl)
  07CB' A0                      	and	b
  07CC' CA 07D2'                	jp	z,reselect1
  07CF' 7E                      	ld	a,(hl)
  07D0' A1                      	and	c
  07D1' 70                      	ld	(hl),b
                                
  07D2'                         reselect1:
  07D2' 32 08BC'                	ld	(actual$rc),a
                                
  07D5' 21 0000                 	ld	hl,0
  07D8' 22 08CA'                	ld	(fcbdsk),hl	; fcbdsk = 0
  07DB' 3E FF                   	ld	a,true
  07DD' 32 08E1'                	ld	(resel),a	; Mark possible reselect
  07E0' 2A 08DF'                	ld	hl,(info)
  07E3' 7E                      	ld	a,(hl)		; drive select code
  07E4' E6 1F                   	and	00011111b		; non zero is auto drive select
  07E6' 3D                      	dec	a		; Drive code normalized to 0..30, or 255
  07E7' 32 08BA'                	ld	(linfo),a	; Save drive code
  07EA' FE FF                   	cp	0ffh
  07EC' CA 07F6'                	jp	z,noselect
                                				; auto select function, seldsk saved above
  07EF' 7E                      	ld	a,(hl)
  07F0' 32 08CA'                	ld	(fcbdsk),a	; Save drive code
  07F3' CD 079B'                	call	set$seldsk
                                
  07F6'                         noselect:
  07F6' CD 076F'                	call	curselect
  07F9' 3E 00                   	ld	a,0
  07FB' 2A 08DF'                	ld	hl,(info)
  07FE' 77                      	ld	(hl),a
  07FF' C9                      	ret
                                
                                ;
                                ;	individual function handlers
                                ;
                                
  02E8' =                       func12	equ	func$ret
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   31
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0800'                         func13:
                                
                                				; Reset disk system - initialize to disk 0
  0800' 21 0000                 	ld	hl,0
  0803' 22 0888'                	ld	(dlog),hl
                                
  0806' AF                      	xor	a
  0807' 32 08DE'                	ld	(seldsk),a
  080A' 3D                      	dec	a
  080B' 32 08C2'                	ld	(curdsk),a
                                
  080E' 21 0080                 	ld	hl,tbuff
  0811' 22 08DC'                	ld	(dmaad),hl	; dmaad = tbuff
  0814' C3 059B'                	jp	setdata		; to data dma address
                                
  0817'                         func14:	
                                				; Select disk info
  0817' CD 079B'                	call	set$seldsk	; seldsk = linfo
  081A' C3 076F'                	jp	curselect
                                
  081D'                         func15:
                                				; Open file
  081D' CD 07A2'                	call	reselectx
  0820' CD 06A2'                	call	open
  0823' CD 0827'                	call	openx		; returns if unsuccessful, a = 0
  0826' C9                      	ret
                                
  0827'                         openx:
  0827' CD 05AB'                	call	end$of$dir
  082A' C8                      	ret	z
  082B' CD 04F6'                	call	getfcba
  082E' 7E                      	ld	a,(hl)
  082F' 3C                      	inc	a
  0830' C2 0837'                	jp	nz,openxa
  0833' 1B                      	dec	de
  0834' 1B                      	dec	de
  0835' 1A                      	ld	a,(de)
  0836' 77                      	ld	(hl),a
  0837'                         openxa:
                                				; open successful
  0837' E1                      	pop	hl		; Discard return address
  0838' 0E 40                   	ld	c,01000000b
  083A' C9                      	ret
                                
  02E8' =                       func16	equ	func$ret
                                
  02E8' =                       func17	equ	func$ret
                                
  02E8' =                       func18	equ	func$ret
                                
  02E8' =                       func19	equ	func$ret
                                
  083B'                         func20:
                                				; Read a file
  083B' CD 07A9'                	call	reselect
  083E' C3 0737'                	jp	seqdiskread
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   32
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  02E8' =                       func21	equ	func$ret
                                
  02E8' =                       func22	equ	func$ret
                                
  02E8' =                       func23	equ	func$ret
                                
  02E8' =                       func24	equ	func$ret
                                
  0841' 3A 08DE'                func25:	ld	a,(seldsk)
  0844' C3 02E5'                	jp	sta$ret
                                
  0847' EB                      func26:	ex	de,hl
  0848' 22 08DC'                	ld	(dmaad),hl
  084B' C3 059B'                	jp	setdata
                                
  02E8' =                       func27	equ	func$ret
                                
  02E8' =                       func28	equ	func$ret
                                
  02E8' =                       func29	equ	func$ret
                                
  02E8' =                       func30	equ	func$ret
                                
  02E8' =                       func31	equ	func$ret
                                
  02E8' =                       func32	equ	func$ret
                                
  02E8' =                       func33	equ	func$ret
                                
  02E8' =                       func34	equ	func$ret
                                
  02E8' =                       func35	equ	func$ret
                                
  02E8' =                       func36	equ	func$ret
                                
  02E8' =                       func37	equ	func$ret
                                
  02E8' =                       func38	equ	func$ret
                                
  02E8' =                       func39	equ	func$ret
                                
  02E8' =                       func40	equ	func$ret
                                
  02E8' =                       func42	equ	func$ret
                                
  02E8' =                       func43	equ	func$ret
                                
  02E8' =                       func44	equ	func$ret
                                
  02E8' =                       func45	equ	func$ret
                                
  02E8' =                       func46	equ	func$ret
                                
  02E8' =                       func47	equ	func$ret
                                
  02E8' =                       func48	equ	func$ret
                                
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   33
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  02E8' =                       func49	equ	func$ret
                                
  02E8' =                       func50	equ	func$ret
                                
  02E8' =                       func100 equ	func$ret
                                
  02E8' =                       func101 equ	func$ret
                                
  02E8' =                       func102 equ	func$ret
                                
  02E8' =                       func103 equ	func$ret
                                
  02E8' =                       func104 equ	func$ret
                                
  02E8' =                       func105 equ	func$ret
                                
  02E8' =                       func106 equ	func$ret
                                
  02E8' =                       func107 equ	func$ret
                                
  02E8' =                       func108 equ	func$ret
                                
  02E8' =                       func109 equ	func$ret
                                
                                
  084E'                         goback:
                                				; Arrive here at end of processing to return to user
  084E' 3A 08E2'                	ld	a,(fx)
  0851' FE 0F                   	cp	15
  0853' DA 087E'                	jp	c,retmon
  0856' 3A 08BE'                	ld	a,(olddsk)
  0859' 32 08DE'                	ld	(seldsk),a	; Restore seldsk
  085C' 3A 08E1'                	ld	a,(resel)
  085F' B7                      	or	a
  0860' CA 087E'                	jp	z,retmon
                                
  0863' 2A 08DF'                	ld	hl,(info)
  0866' 36 00                   	ld	(hl),0		; fcb(0)=0
  0868' 3A 08CA'                	ld	a,(fcbdsk)
  086B' B7                      	or	a
  086C' CA 0870'                	jp	z,goback1
                                				; Restore fcb(0)
  086F' 77                      	ld	(hl),a		; fcb(0)=fcbdsk
  0870'                         goback1:
                                				; fcb(8) = fcb(8) | high$ext
  0870' 23                      	inc	hl
  0871' 3A 08C8'                	ld	a,(high$ext)
  0874' B6                      	or	(hl)
  0875' 77                      	ld	(hl),a
                                				; fcb(rc) = fcb(rc) | actual$rc
  0876' CD 04EE'                	call	getrcnta
  0879' 3A 08BC'                	ld	a,(actual$rc)
  087C' B6                      	or	(hl)
  087D' 77                      	ld	(hl),a
                                				; return from the disk monitor
  087E'                         retmon:
  087E' 2A 0240'                	ld	hl,(entsp)
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   34
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0881' F9                      	ld	sp,hl
  0882' 2A 0309'                	ld	hl,(aret)
  0885' 7D                      	ld	a,l
  0886' 44                      	ld	b,h
  0887' C9                      	ret
                                ;
                                ;	data areas
                                ;
  0888' 0000                    dlog:	defw	0		; logged-in disks
  088A' ( 0002 )                curdma:	defs	word		; current dma address
  088C' ( 0002 )                buffa:	defs	word		; pointer to directory dma address
                                
                                ;
                                ;	curtrka - alloca are set upon disk select
                                ;	(data must be adjacent, do not insert variables)
                                ;	(address of translate vector, not used)
  088E' ( 0002 )                cdrmaxa:defs	word		; pointer to cur dir max value (2 bytes)
  0890' ( 0002 )                curtrka:defs	word		; current track address (2)
  0892' ( 0002 )                curreca:defs	word		; current record address (3)
  0894' ( 0002 )                drvlbla:defs	word		; current drive label byte address (1)
  0896' ( 0002 )                lsn$add:defs	word		; login sequence # address (1)
                                				; +1 -> bios media change flag (1)
  0898' ( 0002 )                dpbaddr:defs	word		; current disk parameter block address
  089A' ( 0002 )                checka:	defs	word		; current checksum vector address
  089C' ( 0002 )                alloca:	defs	word		; current allocation vector address
  089E' ( 0002 )                dirbcba:defs	word		; dir bcb list head
  08A0' ( 0002 )                dtabcba:defs	word		; data bcb list head
  08A2'                         hash$tbla:
  08A2' ( 0002 )                	defs	word
  08A4' ( 0001 )                	defs	byte
                                
  000D  =                       addlist equ	$-dpbaddr	; address list size
                                
                                ;
                                ; 	       buffer control block format
                                ;
                                ; bcb format : drv(1) || rec(3) || pend(1) || sequence(1) ||
                                ;	       0         1         4          5
                                ;
                                ;	       track(2) || sector(2) || buffer$add(2) ||
                                ;	       6           8            10
                                ;
                                ;	       link(2)
                                ;	       12
                                ;
                                
                                ;	sectpt - offset obtained from disk parm block at dpbaddr
                                ;	(data must be adjacent, do not insert variables)
  08A5' ( 0002 )                sectpt:	defs	word		; sectors per track
  08A7' ( 0001 )                blkshf:	defs	byte		; block shift factor
  08A8' ( 0001 )                blkmsk:	defs	byte		; block mask
  08A9' ( 0001 )                extmsk:	defs	byte		; extent mask
  08AA' ( 0002 )                maxall:	defs	word		; maximum allocation number
  08AC' ( 0002 )                dirmax:	defs	word		; largest directory number
  08AE' ( 0002 )                dirblk:	defs	word		; reserved allocation bits for directory
  08B0' ( 0002 )                chksiz:	defs	word		; size of checksum vector
  08B2' ( 0002 )                offset:	defs	word		; offset tracks at beginning
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   35
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  08B4' ( 0001 )                physhf:	defs	byte		; physical record shift
  08B5' ( 0001 )                phymsk:	defs	byte		; physical record mask
  0011  =                       dpblist equ	$-sectpt	; size of area
                                ;
                                ;	local variables
                                ;
  08B6' ( 0001 )                blk$off:defs	byte		; record offset within block
  08B7' ( 0001 )                dir$cnt:defs	byte		; direct i/o count
                                
  08B8' ( 0002 )                tranv:	defs	word		; address of translate vector
  08BA' ( 0001 )                linfo:	defs	byte		; low(info)
  08BB' ( 0001 )                dminx:	defs	byte		; local for diskwrite
                                
  08BC'                         actual$rc:
  08BC' ( 0001 )                	defs	byte		; directory ext record count
                                
  08BD' ( 0001 )                single:	defs	byte		; set true if single byte allocation map
                                
                                
  08BE' ( 0001 )                olddsk:	defs	byte		; disk on entry to bdos
  08BF' ( 0001 )                rcount:	defs	byte		; record count in current fcb
  08C0' ( 0001 )                extval:	defs	byte		; extent number and extmsk
                                
  08C1' ( 0001 )                vrecord:defs	byte		; current virtual record
                                
  08C2'                         curdsk:
                                
  08C2' FF                      adrive:	defb	0ffh		; current disk
  08C3' ( 0002 )                arecord:defs	word		; current actual record
  08C5' ( 0001 )                	defs	byte
                                
  08C6'                         arecord1:
  08C6' ( 0002 )                	defs	word		; current actual block# * blkmsk
                                
                                ;******** following variable order critical *****************
                                
  08C8'                         high$ext:
  08C8' ( 0001 )                	defs	byte		; fcb high ext bits
                                ;xfcb$read$only:	ds	byte
                                
                                ;	local variables for directory access
  08C9' ( 0001 )                dptr:	defs	byte		; directory pointer 0,1,2,3
                                
                                ;
                                ;	local variables initialized by bdos at entry
                                ;
  08CA' ( 0001 )                fcbdsk:	defs	byte		; disk named in fcb
                                
  08CB' ( 0001 )                phy$off:defs	byte
  08CC' ( 0002 )                curbcba:defs	word
                                
  08CE' ( 0002 )                track:	defs	word
  08D0' ( 0002 )                sector:	defs	word
                                
  08D2'                         read$deblock:
  08D2' 3E 01                   	ld	a,1
  08D4' CD 08EE'                	call	deblock$dta
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   36
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  08D7' C3 0516'                	jp	setfcb
                                
  08DA' 00                      column:	defb	0
  08DB'                         outdelim:
  08DB' 24                      	defb	'$'
                                
  08DC' 0080                    dmaad:	defw	0080h
  08DE' 00                      seldsk:	defb	0
  08DF' 0000                    info:	defw	0
  08E1' 00                      resel:	defb	0
  08E2' 00                      fx:	defb	0
  08E3' 0000                    dcnt:	defw	0
  08E5' 0000                    searcha:defw	0
  08E7' 00                      searchl:defb	0
                                
                                
                                ; 	**************************
                                ; 	Blocking/Deblocking Module
                                ;	**************************
                                
  08E8'                         deblock$dir:
                                
  08E8' 2A 089E'                	ld	hl,(dirbcba)
                                
  08EB' C3 08F1'                	jp	deblock
                                
  08EE'                         deblock$dta:
  08EE' 2A 08A0'                	ld	hl,(dtabcba)
                                
  08F1'                         deblock:
                                
                                				; BDOS Blocking/Deblocking routine
                                				; a = 1 -> read command
                                				; a = 2 -> write command
                                				; a = 3 -> locate command
                                				; a = 4 -> flush command
                                				; a = 5 -> directory update
                                
  08F1' F5                      	push	af		; Save z flag and deblock fx
                                
                                				; phy$off = low(arecord) & phymsk
                                				; low(arecord) = low(arecord) & ~phymsk
  08F2' CD 0954'                	call	deblock8
  08F5' 3A 08C3'                	ld	a,(arecord)
  08F8' 5F                      	ld	e,a
  08F9' A0                      	and	b
  08FA' 32 08CB'                	ld	(phy$off),a
  08FD' 7B                      	ld	a,e
  08FE' A1                      	and	c
  08FF' 32 08C3'                	ld	(arecord),a
                                
  0902' 22 08CC'                	ld	(curbcba),hl
  0905' CD 0572'                	call	getbuffa
  0908' 22 088A'                	ld	(curdma),hl
                                
  090B' CD 095B'                	call	deblock9
                                				; Is command flush?
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   37
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  090E' F1                      	pop	af
  090F' F5                      	push	af
  0910' FE 04                   	cp	4
  0912' D2 091C'                	jp	nc,deblock1	; yes
                                				; Is referenced physical record 
                                				; Already in buffer?
  0915' CD 033F'                	call	compare
  0918' CA 092C'                	jp	z,deblock45	; yes
  091B' AF                      	xor	a
  091C'                         deblock1:
  091C' CD 0964'                	call	deblock10
                                				; Read physical record buffer
  091F' 3E 02                   	ld	a,2
  0921' CD 096C'                	call	deblock$io
                                
  0924' CD 095B'                	call	deblock9	; phypfx = adrive || arecord
  0927' CD 0349'                	call	move
  092A' 36 00                   	ld	(hl),0		; zero pending flag
                                
  092C'                         deblock45:
                                				; recadd = phybuffa + phy$off*80h
  092C' 3A 08CB'                	ld	a,(phy$off)
  092F' 3C                      	inc	a
  0930' 11 0080                 	ld	de,80h
  0933' 21 FF80                 	ld	hl,0ff80h
  0936'                         deblock5:
  0936' 19                      	add	hl,de
  0937' 3D                      	dec	a
  0938' C2 0936'                	jp	nz,deblock5
  093B' EB                      	ex	de,hl
  093C' 2A 088A'                	ld	hl,(curdma)
  093F' 19                      	add	hl,de
                                				; If deblock command = locate
                                				; then buffa = recadd; return
  0940' F1                      	pop	af
  0941' FE 03                   	cp	3
  0943' C2 094A'                	jp	nz,deblock6
  0946' 22 088C'                	ld	(buffa),hl
  0949' C9                      	ret
  094A'                         deblock6:
  094A' EB                      	ex	de,hl
  094B' 2A 08DC'                	ld	hl,(dmaad)
  094E' 01 0080                 	ld	bc,80h
                                				; If deblock command = read
  0951' C3 0A4B'                	jp	move$tpa	; then move to dma
                                
  0954'                         deblock8:
  0954' 3A 08B5'                	ld	a,(phymsk)
  0957' 47                      	ld	b,a
  0958' 2F                      	cpl
  0959' 4F                      	ld	c,a
  095A' C9                      	ret
                                
  095B'                         deblock9:
  095B' 2A 08CC'                	ld	hl,(curbcba)
  095E' 11 08C2'                	ld	de,adrive
  0961' 0E 04                   	ld	c,4
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   38
CP/M 3.0 LDRBDOS Interface, Version 3.1 July, 1982

  0963' C9                      	ret
                                
  0964'                         deblock10:
  0964' 11 0004                 	ld	de,4
  0967'                         deblock11:
  0967' 2A 08CC'                	ld	hl,(curbcba)
  096A' 19                      	add	hl,de
  096B' C9                      	ret
                                
  096C'                         deblock$io:
                                				; a = 0 -> seek only
                                				; a = 1 -> write
                                				; a = 2 -> read
  096C' F5                      	push	af
  096D' CD 03DA'                	call	seek
  0970' F1                      	pop	af
  0971' 3D                      	dec	a
  0972' F4 03B3'                	call	p,rdbuff
                                				; Move track & sector to bcb
  0975' CD 0964'                	call	deblock10
  0978' 23                      	inc	hl
  0979' 23                      	inc	hl
  097A' 11 08CE'                	ld	de,track
  097D' 0E 04                   	ld	c,4
  097F' C3 0349'                	jp	move
                                
  0982' ( 007D )                	defs	255 - (($-rbase) and 00ffh) ; To last byte on this page
                                
  09FF' 00                      	defb	0
                                
                                ; Bios equates
                                
  0A00' =                       bios$pg equ	$
                                
  0A00' =                       bootf	equ	bios$pg+00	; 00. cold boot
  0A0C' =                       conoutf equ	bios$pg+12	; 04. console output function
  0A18' =                       homef	equ	bios$pg+24	; 08. disk home function
  0A1B' =                       seldskf equ	bios$pg+27	; 09. select disk function
  0A1E' =                       settrkf equ	bios$pg+30	; 10. set track function
  0A21' =                       setsecf equ	bios$pg+33	; 11. set sector function
  0A24' =                       setdmaf equ	bios$pg+36	; 12. set dma function
  0A27' =                       readf	equ	bios$pg+39	; 13. read disk function
  0A30' =                       sectran equ	bios$pg+48	; 16. sector translate
  0A4B' =                       movef	equ	bios$pg+75	; 25. memory move function
  0A4B' =                       move$out equ	movef
  0A4B' =                       move$tpa equ	movef
                                
  0000  =                       	end

Errors: 0
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   39

Symbols:
$EXECUTE ......... 005F'P ABASE ............ 0000   ACTUAL$RC ........ 08BC'
ADDLIST .......... 000D   ADRIVE ........... 08C2'  ALLOCA ........... 089C'
ARECORD .......... 08C3'  ARECORD1 ......... 08C6'  ARET ............. 0309'
ATRAN ............ 04C0'  BANK$LEN ......... 0184'P BANK$TOP ......... 0183'P
BASE ............. 0000   BDE$E$BDE$M$HL ... 0325'  BDE$E$BDE$P$HL ... 032E'
BDOS ............. 018D'P BDOS$JMP ......... 01CF'  BDOSE ............ 018D'P
BDOSE2 ........... 01A5'  BIOS$PG .......... 0A00'  BLK$OFF .......... 08B6'
BLKMSK ........... 08A8'  BLKSHF ........... 08A7'  BNKLEN ........... 0083 
BNKTOP ........... 0082   BOOTF ............ 0A00'  BREAK ............ 00A9'P
BUFF ............. 0080   BUFFA ............ 088C'  BYTE ............. 0001 
CDRMAXA .......... 088E'  CHECKA ........... 089A'  CHKSIZ ........... 08B0'
CLOOP ............ 0034'P CLR$EXT .......... 0563'  COLUMN ........... 08DA'
COMLEN ........... 0081   COMPARE .......... 033F'  COMPCOL .......... 02EE'
COMPEXT .......... 05E3'  COMPOUT .......... 029E'  COMTOP ........... 0080 
CONOUT ........... 0292'  CONOUTF .......... 0A0C'  CPMFCB ........... 00AB'P
CR ............... 000D   CTLH ............. 0008   CURBCBA .......... 08CC'
CURDMA ........... 088A'  CURDSK ........... 08C2'  CURRECA .......... 0892'
CURSELECT ........ 076F'  CURTRKA .......... 0890'  DCNT ............. 08E3'
DEBLOCK .......... 08F1'  DEBLOCK$DIR ...... 08E8'  DEBLOCK$DTA ...... 08EE'
DEBLOCK$IO ....... 096C'  DEBLOCK1 ......... 091C'  DEBLOCK10 ........ 0964'
DEBLOCK11 ........ 0967'  DEBLOCK45 ........ 092C'  DEBLOCK5 ......... 0936'
DEBLOCK6 ......... 094A'  DEBLOCK8 ......... 0954'  DEBLOCK9 ......... 095B'
DIOCOMP .......... 03B9'  DIR$CNT .......... 08B7'  DIRBCBA .......... 089E'
DIRBLK ........... 08AE'  DIRMAX ........... 08AC'  DIRREC ........... 0004 
DISKF ............ 000C   DLOG ............. 0888'  DM$POSITION ...... 0472'
DMAAD ............ 08DC'  DMINX ............ 08BB'  DMPOS0 ........... 0479'
DMPOS1 ........... 0487'  DMPOS2 ........... 0490'  DPBADDR .......... 0898'
DPBLIST .......... 0011   DPTR ............. 08C9'  DRVLBLA .......... 0894'
DSKMAP ........... 0010   DSKMSK ........... 0003   DSKSHF ........... 0002 
DTABCBA .......... 08A0'  EMPTY ............ 00E5   END$OF$DIR ....... 05AB'
ENDDIR ........... FFFF   ENDSEARCH ........ 0694'  ENTSP ............ 0240'
ERR$MSG .......... 02EF'  ERR$PHYS ......... 0303'  ERR$SELECT ....... 02FC'
ERROR ............ 00A2'P EXECUTE$SYS ...... 006F'  EXTMSK ........... 08A9'
EXTNUM ........... 000C   EXTVAL ........... 08C0'  FALSE ............ 0000 
FCB .............. 005C   FCBDSK ........... 08CA'  FCBLEN ........... 0020 
FCBSHF ........... 0005   FUNC$RET ......... 02E8'  FUNC1 ............ 02E8'
FUNC10 ........... 02E8'  FUNC100 .......... 02E8'  FUNC101 .......... 02E8'
FUNC102 .......... 02E8'  FUNC103 .......... 02E8'  FUNC104 .......... 02E8'
FUNC105 .......... 02E8'  FUNC106 .......... 02E8'  FUNC107 .......... 02E8'
FUNC108 .......... 02E8'  FUNC109 .......... 02E8'  FUNC11 ........... 02E8'
FUNC12 ........... 02E8'  FUNC13 ........... 0800'  FUNC14 ........... 0817'
FUNC15 ........... 081D'  FUNC16 ........... 02E8'  FUNC17 ........... 02E8'
FUNC18 ........... 02E8'  FUNC19 ........... 02E8'  FUNC2 ............ 02BB'
FUNC20 ........... 083B'  FUNC21 ........... 02E8'  FUNC22 ........... 02E8'
FUNC23 ........... 02E8'  FUNC24 ........... 02E8'  FUNC25 ........... 0841'
FUNC26 ........... 0847'  FUNC27 ........... 02E8'  FUNC28 ........... 02E8'
FUNC29 ........... 02E8'  FUNC3 ............ 02E8'  FUNC30 ........... 02E8'
FUNC31 ........... 02E8'  FUNC32 ........... 02E8'  FUNC33 ........... 02E8'
FUNC34 ........... 02E8'  FUNC35 ........... 02E8'  FUNC36 ........... 02E8'
FUNC37 ........... 02E8'  FUNC38 ........... 02E8'  FUNC39 ........... 02E8'
FUNC40 ........... 02E8'  FUNC42 ........... 02E8'  FUNC43 ........... 02E8'
FUNC44 ........... 02E8'  FUNC45 ........... 02E8'  FUNC46 ........... 02E8'
FUNC47 ........... 02E8'  FUNC48 ........... 02E8'  FUNC49 ........... 02E8'
FUNC50 ........... 02E8'  FUNC6 ............ 02E8'  FUNC9 ............ 02DF'
FUNCTAB .......... 01DC'  FX ............... 08E2'  GET$DE0 .......... 05FC'
GET$DE1 .......... 05FF'  GET$DE2 .......... 0609'  GET$DE3 .......... 0616'
GET$DIR$EXT ...... 05F4'  GETBUFFA ......... 0572'  GETDM ............ 049A'
ZSM 4.1	Source file: CPMLDR3  	22-Oct-2019  09:59:51	Page   40

GETDMA ........... 0492'  GETDMD ........... 04A8'  GETDPTRA ......... 0558'
GETEXTA .......... 04E6'  GETFCB ........... 04FF'  GETFCBA .......... 04F6'
GETRCNTA ......... 04EE'  GOBACK ........... 084E'  GOBACK1 .......... 0870'
GOERR ............ 0317'  GOERR1 ........... 0320'  HASH$TBLA ........ 08A2'
HIGH$EXT ......... 08C8'  HIGH$FXS ......... 01CA'  HLROTL ........... 0533'
HLROTL0 .......... 0534'  HLROTR ........... 0526'  HLROTR0 .......... 0527'
HOME ............. 0397'  HOMEF ............ 0A18'  INDEX ............ 04AE'
INFO ............. 08DF'  LF ............... 000A   LINFO ............ 08BA'
LOAD ............. 0073'P LOOP ............. 007A'P LRET ............. 0309'
LRET$EQ$FF ....... 069B'  LSN$ADD .......... 0896'  LSTACK ........... 0292'
MAXALL ........... 08AA'  MAXEXT ........... 001F   MD ............... 0024 
MEM$TOP .......... 0181'P MOVE ............. 0349'  MOVE$OUT ......... 0A4B'
MOVE$TPA ......... 0A4B'  MOVE0 ............ 034A'  MOVEF ............ 0A4B'
NAMLEN ........... 000F   NFUNCS ........... 0032   NOSELECT ......... 07F6'
NOTBACKSP ........ 02B5'  NXTREC ........... 0020   OFFSET ........... 08B2'
OLDDSK ........... 08BE'  OPEN ............. 06A2'  OPEN$COPY ........ 06A8'
OPEN$FUNC ........ 000F   OPEN$REEL ........ 06FF'  OPEN$REEL2 ....... 0717'
OPEN$REEL3 ....... 0721'  OPEN$REEL4 ....... 072E'  OPENERR .......... 00CF'P
OPENX ............ 0827'  OPENXA ........... 0837'  OSENTRY .......... 0084 
OSENTRY$ADR ...... 0185'P OUTDELIM ......... 08DB'  PASS$ARECORD ..... 03AA'
PHY$OFF .......... 08CB'  PHYMSK ........... 08B5'  PHYSHF ........... 08B4'
PRINT ............ 02CF'  PRINTBUF ......... 0009   RBASE ............ 0000'P
RCOUNT ........... 08BF'  RD$DIR ........... 057D'  RDBUFF ........... 03B3'
RDDIR1 ........... 058F'  READ$DEBLOCK ..... 08D2'  READ$DIR ......... 05BB'
READ$DIR1 ........ 05D3'  READ$FUNC ........ 0014   READ$PROC ........ 0095'P
READERR .......... 00FA'P READF ............ 0A27'  RECCNT ........... 000F 
RECORDOK ......... 0753'  RECSIZ ........... 0080   RES$LEN .......... 0182'P
RESEL ............ 08E1'  RESELECT ......... 07A9'  RESELECT1 ........ 07D2'
RESELECTX ........ 07A2'  RESETSYS ......... 000D   RESTORE$RC ....... 06EC'
RESTORE$RC1 ...... 06FD'  RETMON ........... 087E'  RETSELECT ........ 0395'
RUBOUT ........... 007F   SEARCH ........... 063A'  SEARCHA .......... 08E5'
SEARCHEXT ........ 0682'  SEARCHL .......... 08E7'  SEARCHLOOP ....... 0668'
SEARCHN .......... 064A'  SEARCHOK ......... 068D'  SECTOR ........... 08D0'
SECTPT ........... 08A5'  SECTRAN .......... 0A30'  SEEK ............. 03DA'
SEEK0 ............ 03F0'  SEEK1 ............ 0407'  SEEK2 ............ 041E'
SEEKDIR .......... 03C6'  SEL$ERROR ........ 030B'  SELDSK ........... 08DE'
SELDSKF .......... 0A1B'  SELECT ........... 077C'  SELECTDISK ....... 0353'
SEQDISKREAD ...... 0737'  SERIAL ........... 0187'  SET$CDISK ........ 053A'
SET$END$DIR ...... 05B4'  SET$RC ........... 06BF'  SET$RC1 .......... 06D2'
SET$RC2 .......... 06D8'  SET$SELDSK ....... 079B'  SETDATA .......... 059B'
SETDIR ........... 05A1'  SETDMA ........... 05A7'  SETDMA$FUNC ...... 001A 
SETDMA$PROC ...... 008F'P SETDMAF .......... 0A24'  SETFCB ........... 0516'
SETLRET1 ......... 02E9'  SETSECF .......... 0A21'  SETTRKF .......... 0A1E'
SHL3BV ........... 0337'  SHL3BV1 .......... 0338'  SHR$PHYSHF ....... 046B'
SIGNON ........... 0132'P SINGLE ........... 08BD'  STA$RET .......... 02E5'
STACKBOT ......... 0181'P SUBDH ............ 056B'  TAB .............. 0009 
TAB0 ............. 02C1'  TABOUT ........... 02BB'  TBUFF ............ 0080 
TEST ............. 0001 P TEST$VECTOR ...... 054D'  TRACK ............ 08CE'
TRANV ............ 08B8'  TRUE ............. 00FF   UBYTES ........... 000D 
VRECORD .......... 08C1'  WORD ............. 0002   
